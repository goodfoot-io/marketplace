# Streamable HTTP Protocol Specification

## Protocol Overview

Streamable HTTP is the modern transport mechanism for MCP, replacing the deprecated SSE-only approach. It uses a single endpoint that dynamically handles both immediate responses and streaming operations.

## Endpoint Requirements

### Single MCP Endpoint
- **Path**: Typically `/mcp` (configurable)
- **Methods**: Both `POST` and `GET`
- **Content Types**:
  - Request: `application/json`
  - Response: `application/json` OR `text/event-stream`

### HTTP Headers

#### Required Client Headers
```http
Content-Type: application/json
Accept: application/json, text/event-stream
```

#### Optional Session Header
```http
Mcp-Session-Id: <session-id>
```
- Generated by server during `initialize` request
- MUST be included in all subsequent requests from the same client
- Server returns 404 if session ID is invalid or expired

#### Security Headers (Recommended)
```http
Origin: https://example.com
Authorization: Bearer <token>
```

## Request Types and Flow

### 1. POST Requests

#### A. JSON-RPC Requests (Expecting Response)
Client sends a request that expects a response:

```http
POST /mcp HTTP/1.1
Content-Type: application/json
Accept: application/json, text/event-stream
Mcp-Session-Id: abc123

{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "add",
    "arguments": { "a": 5, "b": 3 }
  },
  "id": 42
}
```

**Server Response Options:**

**Option 1: Immediate JSON Response**
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "jsonrpc": "2.0",
  "result": {
    "content": [
      { "type": "text", "text": "Result: 8" }
    ]
  },
  "id": 42
}
```

**Option 2: Stream Multiple Messages via SSE**
```http
HTTP/1.1 200 OK
Content-Type: text/event-stream
Mcp-Session-Id: abc123

data: {"jsonrpc":"2.0","method":"notifications/progress","params":{"progress":25}}

data: {"jsonrpc":"2.0","method":"notifications/progress","params":{"progress":50}}

data: {"jsonrpc":"2.0","method":"notifications/progress","params":{"progress":75}}

data: {"jsonrpc":"2.0","result":{"content":[{"type":"text","text":"Result: 8"}]},"id":42}
```

#### B. JSON-RPC Notifications (No Response Expected)
Client sends a notification (no `id` field):

```http
POST /mcp HTTP/1.1
Content-Type: application/json
Mcp-Session-Id: abc123

{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": { "requestId": 41 }
}
```

**Server Response:**
```http
HTTP/1.1 202 Accepted
```
No response body required for notifications.

#### C. JSON-RPC Responses (Client Responding to Server)
Client sends a response to a server request:

```http
POST /mcp HTTP/1.1
Content-Type: application/json
Mcp-Session-Id: abc123

{
  "jsonrpc": "2.0",
  "result": { "approved": true },
  "id": 99
}
```

**Server Response:**
```http
HTTP/1.1 202 Accepted
```

#### D. Batched Requests
Multiple messages in one POST:

```http
POST /mcp HTTP/1.1
Content-Type: application/json
Mcp-Session-Id: abc123

[
  {
    "jsonrpc": "2.0",
    "method": "tools/list",
    "id": 1
  },
  {
    "jsonrpc": "2.0",
    "method": "prompts/list",
    "id": 2
  }
]
```

**Server Response:**
```http
HTTP/1.1 200 OK
Content-Type: application/json

[
  {
    "jsonrpc": "2.0",
    "result": { "tools": [...] },
    "id": 1
  },
  {
    "jsonrpc": "2.0",
    "result": { "prompts": [...] },
    "id": 2
  }
]
```

### 2. GET Requests (SSE Stream)

Used to establish a long-lived listening stream for server-initiated messages:

```http
GET /mcp HTTP/1.1
Accept: text/event-stream
Mcp-Session-Id: abc123
```

**Server Response:**
```http
HTTP/1.1 200 OK
Content-Type: text/event-stream
Mcp-Session-Id: abc123

: comment - connection established

data: {"jsonrpc":"2.0","method":"notifications/tools/list_changed","params":{}}

data: {"jsonrpc":"2.0","method":"tools/call","params":{"name":"confirm","arguments":{"message":"Continue?"}},"id":100}
```

#### Optional Resumability
Client can request to resume from last received event:

```http
GET /mcp HTTP/1.1
Accept: text/event-stream
Mcp-Session-Id: abc123
Last-Event-ID: 1234567890
```

Server resends events after the specified ID (if supported).

## Session Management

### Session Lifecycle

#### 1. Session Creation (Initialize)
First request from client:

```http
POST /mcp HTTP/1.1
Content-Type: application/json
Accept: application/json

{
  "jsonrpc": "2.0",
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": { "listChanged": true }
    },
    "clientInfo": {
      "name": "MyClient",
      "version": "1.0.0"
    }
  },
  "id": 1
}
```

Server response with session ID:

```http
HTTP/1.1 200 OK
Content-Type: application/json
Mcp-Session-Id: abc123def456

{
  "jsonrpc": "2.0",
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "tools": {},
      "prompts": {}
    },
    "serverInfo": {
      "name": "MyMcpServer",
      "version": "1.0.0"
    }
  },
  "id": 1
}
```

#### 2. Session Use
All subsequent requests include session ID:

```http
POST /mcp HTTP/1.1
Mcp-Session-Id: abc123def456
Content-Type: application/json

{
  "jsonrpc": "2.0",
  "method": "tools/list",
  "id": 2
}
```

#### 3. Session Expiration
Server returns 404 for expired/invalid session:

```http
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "Session not found or expired"
}
```

Client should re-initialize to get new session.

### Session ID Requirements

Per MCP specification:
- **Globally unique**: No collisions across all servers
- **Cryptographically secure**: Use secure random generation
- **ASCII-only**: Visible ASCII characters (codes 33-126)
- **Recommended**: UUIDs or secure random tokens

Example implementations:

```typescript
// Node.js / Cloudflare Workers
import { randomUUID } from 'crypto';
const sessionId = randomUUID(); // e.g., "550e8400-e29b-41d4-a716-446655440000"

// Or secure random string
const sessionId = Array.from(crypto.getRandomValues(new Uint8Array(32)))
  .map(b => b.toString(16).padStart(2, '0'))
  .join('');
```

## HTTP Status Codes

### Success Codes

| Code | Usage | Body |
|------|-------|------|
| 200 OK | Response to request | JSON-RPC response or SSE stream |
| 202 Accepted | Response to notification | Empty or status message |

### Error Codes

| Code | Usage | Body |
|------|-------|------|
| 400 Bad Request | Invalid JSON-RPC | Error details (optional) |
| 404 Not Found | Invalid/expired session | Error message (optional) |
| 500 Internal Server Error | Server error | Error details (optional) |

### Error Response Format
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "jsonrpc": "2.0",
  "error": {
    "code": -32600,
    "message": "Invalid Request",
    "data": "Missing required field: method"
  },
  "id": null
}
```

## SSE (Server-Sent Events) Format

### Event Structure
```
data: <json-rpc-message>
\n\n
```

### Single-Line Events
```
data: {"jsonrpc":"2.0","method":"ping","params":{}}

```

### Multi-Line Events
```
data: {
data:   "jsonrpc": "2.0",
data:   "result": {
data:     "value": 42
data:   },
data:   "id": 1
data: }

```

### Event IDs (Optional)
```
id: 1234567890
data: {"jsonrpc":"2.0","method":"ping","params":{}}

```

### Comments (Optional)
```
: This is a comment (heartbeat)

data: {"jsonrpc":"2.0","method":"ping","params":{}}

```

## Security Considerations

### 1. Origin Validation
```typescript
const origin = request.headers.get('Origin');
const allowedOrigins = ['https://claude.ai', 'http://localhost:3000'];

if (origin && !allowedOrigins.includes(origin)) {
  return new Response('Forbidden', { status: 403 });
}
```

### 2. Session Security
```typescript
// Store session â†’ Durable Object mapping securely
// Validate session ID format before lookup
if (!/^[a-zA-Z0-9\-_]{32,}$/.test(sessionId)) {
  return new Response('Invalid session ID', { status: 400 });
}
```

### 3. Rate Limiting
```typescript
// Per-session rate limiting in Durable Object
class SessionDO {
  private requestCount = 0;
  private windowStart = Date.now();

  async fetch(request: Request) {
    if (Date.now() - this.windowStart > 60000) {
      this.requestCount = 0;
      this.windowStart = Date.now();
    }

    if (this.requestCount++ > 100) {
      return new Response('Rate limit exceeded', { status: 429 });
    }

    // Process request...
  }
}
```

### 4. Input Validation
```typescript
// Validate JSON-RPC structure
const body = await request.json();
if (!body.jsonrpc || body.jsonrpc !== '2.0') {
  return new Response('Invalid JSON-RPC version', { status: 400 });
}

if (!body.method || typeof body.method !== 'string') {
  return new Response('Invalid method', { status: 400 });
}
```

## Example Complete Flow

### Full Initialize + Tool Call Sequence

```http
# 1. Client initializes
POST /mcp HTTP/1.1
Host: example.com
Content-Type: application/json
Accept: application/json, text/event-stream

{
  "jsonrpc": "2.0",
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {},
    "clientInfo": { "name": "TestClient", "version": "1.0" }
  },
  "id": 1
}

# Server response with session
HTTP/1.1 200 OK
Content-Type: application/json
Mcp-Session-Id: sess_abc123xyz

{
  "jsonrpc": "2.0",
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": { "tools": {} },
    "serverInfo": { "name": "TestServer", "version": "1.0" }
  },
  "id": 1
}

# 2. Client sends initialized notification
POST /mcp HTTP/1.1
Host: example.com
Content-Type: application/json
Mcp-Session-Id: sess_abc123xyz

{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}

# Server acknowledges
HTTP/1.1 202 Accepted

# 3. Client lists tools
POST /mcp HTTP/1.1
Host: example.com
Content-Type: application/json
Mcp-Session-Id: sess_abc123xyz

{
  "jsonrpc": "2.0",
  "method": "tools/list",
  "id": 2
}

# Server returns tools
HTTP/1.1 200 OK
Content-Type: application/json

{
  "jsonrpc": "2.0",
  "result": {
    "tools": [
      {
        "name": "add",
        "description": "Add two numbers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "a": { "type": "number" },
            "b": { "type": "number" }
          },
          "required": ["a", "b"]
        }
      }
    ]
  },
  "id": 2
}

# 4. Client calls tool
POST /mcp HTTP/1.1
Host: example.com
Content-Type: application/json
Accept: application/json, text/event-stream
Mcp-Session-Id: sess_abc123xyz

{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "add",
    "arguments": { "a": 10, "b": 32 }
  },
  "id": 3
}

# Server returns result (immediate)
HTTP/1.1 200 OK
Content-Type: application/json

{
  "jsonrpc": "2.0",
  "result": {
    "content": [
      { "type": "text", "text": "Result: 42" }
    ]
  },
  "id": 3
}
```

## Implementation Checklist

### Server Requirements
- [ ] Accept POST requests to `/mcp` endpoint
- [ ] Parse JSON-RPC 2.0 messages
- [ ] Generate secure session IDs on `initialize`
- [ ] Include `Mcp-Session-Id` in response headers
- [ ] Validate session ID on subsequent requests
- [ ] Return 404 for invalid sessions
- [ ] Support both JSON and SSE responses
- [ ] Handle notifications (return 202)
- [ ] Support batched requests
- [ ] Validate JSON-RPC structure
- [ ] Implement Origin header validation
- [ ] Add rate limiting per session

### Optional Enhancements
- [ ] Support GET requests for SSE listening
- [ ] Implement session resumability (`Last-Event-ID`)
- [ ] Add authentication/authorization
- [ ] Support SSE heartbeat comments
- [ ] Implement graceful session expiration
- [ ] Add request logging and metrics

## Next Steps

- **04-cloudflare-agents-approach.md**: Implementation using Cloudflare Agents SDK
- **05-raw-mcp-sdk-approach.md**: Implementation using raw MCP SDK with Hono
- **06-complete-example.md**: Complete working example with "add" tool
