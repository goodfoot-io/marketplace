# Project Begin Slash Command System

## Overview

The `/project:begin` command is a sophisticated orchestration system that manages the entire lifecycle of project implementation in Claude Code. It combines slash commands, subagents, and utility scripts to create an automated workflow for transforming project plans into production-ready code.

## System Architecture

### Core Components

#### 1. Slash Commands
- **Location**: `.claude/commands/` (project) or `~/.claude/commands/` (user)
- **Format**: Markdown files with optional YAML frontmatter
- **Invocation**: `/command-name [arguments]`
- **Features**:
  - Dynamic arguments via `$ARGUMENTS` placeholder
  - Bash command execution with `!` prefix
  - File references with `@` prefix
  - Tool restrictions via `allowed-tools` frontmatter

#### 2. Subagents
- **Location**: `.claude/agents/` (project) or `~/.claude/agents/` (user)
- **Format**: Markdown with YAML frontmatter defining name, description, and tools
- **Purpose**: Specialized AI assistants with focused expertise
- **Key Benefits**:
  - Separate context windows
  - Task-specific system prompts
  - Configurable tool permissions
  - Automatic or explicit invocation

#### 3. Utility Scripts
- **Location**: `.devcontainer/utilities/`
- **Purpose**: Handle IPC, project management, and process control
- **Key Scripts**:
  - `write-arguments` / `wait-for-arguments`: Argument passing via temp files
  - `get-next-project` / `activate-project`: Project selection and activation
  - `complete-iteration`: Iteration completion and process control
  - `find-claude-pid`: Process identification for IPC

## Syntax and Special Constructs

### Understanding Code Block Types

It's important to distinguish between different code block types in the system:

1. **Embedded Executable Bash** (````!`)
   - Executes when slash command runs
   - Output becomes part of the prompt sent to Claude
   - Used to generate dynamic content

2. **Documentation/Example Bash** (````bash`)
   - Just for documentation or showing examples
   - Not executed
   - Used in markdown for clarity

3. **Tool Function Calls** (plain code blocks)
   - Pattern that Claude recognizes and executes
   - Generated by embedded bash via echo statements
   - Shown in plain code blocks without language identifier

### Embedded Bash Syntax in Slash Commands

Slash commands support two types of embedded bash execution:

#### 1. Inline Bash Commands with Backticks
```markdown
!`command`
```
- Executes immediately when the slash command is invoked
- Output is captured and included in the context
- Example: `!`git status`` includes current git status in the prompt

#### 2. Embedded Bash Code Blocks
````markdown
```!
# Multi-line bash script
VARIABLE=$(command)
echo "Result: $VARIABLE"
```
````
- The `!` immediately after triple backticks marks this as executable bash
- Executes as a complete script block when the slash command runs
- Output becomes part of the content sent to Claude
- Different from ````bash which is just for documentation/examples

### Special Placeholders and Variables

#### In Slash Commands
- **`$ARGUMENTS`**: Replaced with user-provided arguments
- **`@path/to/file`**: Includes file contents in the context
- **`!`command``**: Executes bash and includes output

#### In Embedded Bash Scripts
- **`${CLAUDE_PID}`**: Process ID of Claude instance (used for IPC)
- **`${PROJECT_PATH}`**: Path to active project
- **`${PROJECT_NAME}`**: Name of current project
- **`${BACKTICK}`**: Literal backtick character (for generating markdown)

### YAML Frontmatter Syntax

#### Slash Commands
```yaml
---
description: Brief description of the command
allowed-tools: Bash(git add:*), Read, Write  # Tool restrictions
argument-hint: [project-name]  # Shown in autocomplete
---
```

#### Subagents
```yaml
---
name: agent-name  # Unique identifier
description: When to use this agent
tools: Read, Write, Bash  # Comma-separated or omit for all tools
color: purple  # Optional UI color
model: opus  # Optional model specification
---
```

### Dynamic Content Generation

The orchestrator uses several techniques to generate dynamic content:

#### 1. Conditional Bash Execution
```bash
if [ -z "$PROJECT_PATH" ]; then
    NO_PROJECT_FOUND=true
else
    NO_PROJECT_FOUND=false
fi
```

#### 2. Echo-Based Tool Invocation Generation
Within embedded bash blocks (```!), the orchestrator generates tool invocations:
```bash
echo "Task("
echo '  description="Complete user model",'
echo '  subagent_type="project-implementer",'
echo "  prompt=\`...content...\`"
echo ")"
```
This bash code outputs text that Claude interprets as a tool function call.

#### 3. HERE Documents for Complex Content
```bash
cat > "projects/active/$PROJECT_NAME/log.md" << EOF
# Project Log: $PROJECT_NAME
## Project Activated
Project moved from pending to active on $(date '+%Y-%m-%d %H:%M:%S %Z').
EOF
```

### IPC (Inter-Process Communication) Mechanisms

#### Sync Files
- Pattern: `/tmp/slash_cmd_sync_${CLAUDE_PID}_${TIMESTAMP}`
- Purpose: Signal that data is ready to be consumed
- Cleanup: Old sync files removed before creating new ones

#### Args Files
- Pattern: `/tmp/slash_cmd_args_${CLAUDE_PID}.sh`
- Format: Shell script with `export ARGS="..."`
- Escaping: Special characters escaped to prevent shell interpretation

#### Project Sync Files
- Pattern: `/tmp/slash_cmd_project_sync_${CLAUDE_PID}_${TIMESTAMP}`
- Purpose: Signal project selection completion

### Tool Function Call Syntax

When Claude encounters specific patterns in the slash command output, it interprets them as tool function calls:

#### Task Tool Example
```
Task({
  "description": "Brief task description",
  "subagent_type": "agent-name",
  "prompt": `<project>
    Name: project-name
    Directory: @path/to/project
    Plan: @path/to/plan.md
    Log: @path/to/log.md
    </project>
    
    ## Implementation Objective
    Specific task details
    
    ## Checkpoint Reference
    Task checkpoint SHA: abc123
    
    ## Validation Requirement
    Requirements and baselines`
})
```

Note: The embedded bash uses `echo` statements to output this text pattern, which Claude then executes as a tool call.

#### TodoWrite Tool Example
```
TodoWrite({
  "todos": [
    {
      "content": "Complete user authentication feature with behavioral tests",
      "status": "pending",
      "activeForm": "Completing user authentication feature"
    }
  ]
})
```

#### mcp__file__append Tool Example
```
mcp__file__append({
  "file_path": "/workspace/projects/active/project-name/log.md",
  "content": "## Implementation Summary\n..."
})
```

### File Path References

The system uses several path reference patterns:

- **Absolute paths**: `/workspace/projects/active/project-name`
- **Relative paths**: `projects/pending/project-name`
- **@ references**: `@projects/active/project-name/plan.md` (includes file content)
- **Worktree paths**: `/workspace/.worktrees/[branch-name]/` (for isolated work)

### Git Checkpoint Commands

The orchestrator uses specific git command patterns:

```bash
# Create checkpoint
git add -A 2>/dev/null || true
git commit -m "checkpoint: iteration-$(date +%s)-start" 2>/dev/null || true

# Get checkpoint SHA
BASE_CHECKPOINT=$(git rev-parse HEAD)

# Revert to checkpoint
git reset --hard $TASK_CHECKPOINT
```

### Error Counting Patterns

Validation uses grep patterns to count errors:

```bash
# TypeScript errors
yarn typecheck 2>&1 | grep -c "error TS" || echo "0"

# Test failures  
yarn test 2>&1 | grep -c "FAIL" || echo "0"

# Lint errors
yarn lint 2>&1 | grep -c "error" || echo "0"
```

### Special Escaping Considerations

#### In Bash Scripts
- Variables in echo statements: Use double quotes for expansion, single quotes to prevent
- Backticks in generated markdown: Use `${BACKTICK}` variable
- HERE documents: Use quoted delimiter (`'EOF'`) to prevent variable expansion

#### In Arguments
- Special characters escaped: `\`, `"`, `` ` ``, `$`
- Escaping pattern: `sed 's/\\/\\\\/g; s/"/\\"/g; s/` + "`" + `/\\` + "`" + `/g; s/\$/\\$/g'`

## The `/project:begin` Command Flow

### Phase 1: Project Selection and Activation

1. **Argument Synchronization**
   - `write-arguments` saves user arguments to `/tmp/slash_cmd_args_${CLAUDE_PID}.sh`
   - Creates sync file for IPC coordination

2. **Project Selection**
   - `get-next-project` reads arguments and searches for project
   - Prioritizes: User-specified > Oldest pending with resolved dependencies
   - Returns project path or empty if none found

3. **Project Activation**
   - `activate-project` moves project from pending/ready-for-review to active
   - Handles versioned plan files (plan-v*.md → plan.md)
   - Initializes log.md for new projects
   - Makes plan.md read-only to preserve requirements

### Phase 2: Session State Verification

- Checks for partially completed work without recent evaluation
- Looks for Implementation Summaries without corresponding Evaluation Reports
- If found, proceeds directly to Phase 5 for evaluation before continuing

### Phase 3: Plan Implementation

1. **State Assessment**
   - Reads log.md to catalog:
     - COMPLETED implementations
     - NEEDS_REVISION items with discoveries
     - Latest Evaluation Report issues
     - Created/Modified files
   - Reads plan.md for requirements and success criteria

2. **Task List Creation**
   - Uses TodoWrite tool to create implementation tasks
   - **Core Principle**: One todo per feature, tests included
   - Skips separate test todos (tests are part of implementation)
   - Creates fix todos for evaluation errors
   - Includes retry todos for NEEDS_REVISION items

### Phase 4: Task Execution

1. **Checkpointing Strategy**
   - Creates base checkpoint before any implementation
   - Sequential execution for high-risk tasks (types, models, shared packages)
   - Parallel execution for low-risk tasks (independent features)
   - Individual checkpoints for sequential tasks
   - Batch checkpoint for parallel tasks

2. **Implementation via project-implementer Subagent**
   - **Invocation**: `Task(subagent_type="project-implementer")`
   - **Process**:
     - Fix ALL existing errors first
     - Investigate code systematically
     - Write behavioral tests (TDD)
     - Implement solution
     - Validate with yarn typecheck/test/lint
     - Append summary to log.md
   - **Status Returns**: COMPLETED, NEEDS_REVISION, or BLOCKED

3. **Checkpoint Validation**
   - Compares error counts before/after implementation
   - If errors reduced/maintained: Commits changes
   - If errors increased: Reverts to checkpoint
   - Smart reversion for parallel batches (identifies problematic files)

### Phase 5: Quality Validation

1. **Evaluation via implementation-evaluator Subagent**
   - **Invocation**: `Task(subagent_type="implementation-evaluator")`
   - **Checks**:
     - All tests pass
     - TypeScript compilation succeeds
     - Linting passes
     - Behavioral tests exist
     - Edge cases handled
     - Documentation exists

2. **Status Decision**
   - **PRODUCTION_READY**: Move to ready-for-review, halt
   - **CONTINUE**: Log issues, run `complete-iteration`
   - **BLOCKED**: Log blocking issue, halt

3. **Iteration Completion**
   - `complete-iteration` writes next command to `.claude-next-command`
   - Kills current Claude process with SIGINT
   - Next session automatically continues from checkpoint

## Integration Chain Data Flow

```
User Input (/project:begin [project-name])
    ↓
Orchestrator (begin.md)
    ↓
IPC Utilities (write/wait-for-arguments)
    ↓
Project Management (get-next-project, activate-project)
    ↓
State Assessment (Read log.md, plan.md)
    ↓
Task Planning (TodoWrite)
    ↓
Git Checkpointing (commit snapshots)
    ↓
Implementation (project-implementer subagent)
    ↓
Validation (validation-discovery pipeline)
    ↓
Quality Evaluation (implementation-evaluator subagent)
    ↓
Status Decision (PRODUCTION_READY/CONTINUE/BLOCKED)
    ↓
Iteration Control (complete-iteration)
```

## Key Design Principles

### 1. Checkpoint-Based Recovery
- Every high-risk operation has a checkpoint
- Automatic reversion on failure
- Clean state for retry attempts
- Preserves discoveries in log for learning

### 2. Zero-Error Policy
- Fix ALL errors in plan packages, not just prevent new ones
- Revert changes if unable to achieve zero errors
- Type-first development with comprehensive validation

### 3. Test-Driven Development
- Tests are inseparable from implementation
- One todo per feature including tests
- Behavioral tests validate functionality
- Avoid mocks when possible

### 4. Progressive Implementation
- Fix existing issues → Prototype → Validate → Complete
- Sequential execution for shared dependencies
- Parallel execution for independent features
- Smart reversion identifies problematic changes

### 5. Continuous Evaluation
- Early evaluation for interrupted sessions
- Full evaluation after implementation
- Business risk assessment
- Learning-driven feedback

## Producer-Consumer Relationships

1. **IPC Chain**: write-arguments → wait-for-arguments
2. **Project Selection**: get-next-project → wait-for-project-name
3. **Activation**: activate-project → orchestrator phases
4. **Implementation**: project-implementer → implementation-evaluator
5. **Evaluation**: implementation-evaluator → status decision
6. **Iteration**: complete-iteration → next Claude session

## File Structure

```
.claude/
├── commands/
│   └── project/
│       └── begin.md          # Main orchestrator
├── agents/
│   └── project/
│       ├── project-implementer.md      # Implementation subagent
│       └── implementation-evaluator.md # Evaluation subagent
```

```
.devcontainer/
└── utilities/
    ├── write-arguments       # IPC: Write arguments
    ├── wait-for-arguments    # IPC: Read arguments
    ├── get-next-project      # Select project
    ├── activate-project      # Move to active
    ├── complete-iteration    # End iteration
    └── find-claude-pid       # Process identification
```

## Usage Examples

### Basic Usage
```bash
# Start with next available project
/project:begin

# Start with specific project
/project:begin my-feature-project
```

### Project States
- **pending**: Awaiting implementation
- **active**: Currently being worked on
- **ready-for-review**: Implementation complete, production-ready
- **complete**: Reviewed and finished

### Log Structure
Each project maintains a log.md with:
- Implementation Summaries (what was built)
- Evaluation Reports (quality assessment)
- NEEDS_REVISION discoveries (learning from failures)
- Files Created/Modified (artifacts tracking)

## Best Practices

1. **Plan Files**: Keep plan.md focused on requirements, not implementation details
2. **Dependencies**: Declare project dependencies in YAML frontmatter
3. **Checkpointing**: Let the orchestrator manage checkpoints, don't manually revert
4. **Validation**: Always run full validation on all plan packages
5. **Documentation**: Every implementation appends summary to log.md

## Troubleshooting

### Common Issues

1. **Project Not Found**: Ensure project exists in pending/active/ready-for-review
2. **IPC Timeout**: Check Claude PID detection and temp file permissions
3. **Checkpoint Failures**: Verify git repository state and disk space
4. **Validation Errors**: Fix all errors in plan packages before proceeding

### Recovery Mechanisms

- Session interruption: Automatic early evaluation on resume
- Implementation failure: Checkpoint reversion with discoveries preserved
- System blocking: Halt with clear error reporting
- Process control: complete-iteration ensures clean handoff

This orchestration system transforms behavioral specifications into production-ready code through systematic automation, comprehensive validation, and intelligent error recovery.